import Foundation
import Testing
@testable import ShortcutsMCP

@Suite("ShortcutSigner Tests")
struct ShortcutSignerTests {

    // MARK: - SigningMode Tests

    @Test("SigningMode.anyone has correct raw value")
    func signingModeAnyoneRawValue() {
        #expect(ShortcutSigner.SigningMode.anyone.rawValue == "anyone")
    }

    @Test("SigningMode.peopleWhoKnowMe has correct raw value")
    func signingModePeopleWhoKnowMeRawValue() {
        #expect(ShortcutSigner.SigningMode.peopleWhoKnowMe.rawValue == "people-who-know-me")
    }

    @Test("SigningMode can be created from raw values")
    func signingModeFromRawValue() {
        #expect(ShortcutSigner.SigningMode(rawValue: "anyone") == .anyone)
        #expect(ShortcutSigner.SigningMode(rawValue: "people-who-know-me") == .peopleWhoKnowMe)
        #expect(ShortcutSigner.SigningMode(rawValue: "invalid") == nil)
    }

    // MARK: - SigningError Tests

    @Test("SigningError.inputFileNotFound has descriptive message")
    func inputFileNotFoundError() {
        let error = ShortcutSigner.SigningError.inputFileNotFound(path: "/path/to/file.shortcut")
        #expect(error.errorDescription?.contains("Input shortcut file not found") == true)
        #expect(error.errorDescription?.contains("/path/to/file.shortcut") == true)
    }

    @Test("SigningError.signingFailed has descriptive message")
    func signingFailedError() {
        let error = ShortcutSigner.SigningError.signingFailed(message: "Invalid signature")
        #expect(error.errorDescription?.contains("Failed to sign shortcut") == true)
        #expect(error.errorDescription?.contains("Invalid signature") == true)
    }

    @Test("SigningError.outputFileNotCreated has descriptive message")
    func outputFileNotCreatedError() {
        let error = ShortcutSigner.SigningError.outputFileNotCreated(path: "/path/to/signed.shortcut")
        #expect(error.errorDescription?.contains("Signed shortcut was not created") == true)
        #expect(error.errorDescription?.contains("/path/to/signed.shortcut") == true)
    }

    @Test("SigningError.processError has descriptive message")
    func processErrorDescription() {
        let error = ShortcutSigner.SigningError.processError("Command not found")
        #expect(error.errorDescription?.contains("Process error during signing") == true)
        #expect(error.errorDescription?.contains("Command not found") == true)
    }

    // MARK: - SigningResult Tests

    @Test("SigningResult can be created with all properties")
    func signingResultCreation() {
        let url = URL(filePath: "/path/to/signed.shortcut")
        let result = ShortcutSigner.SigningResult(
            signedFileURL: url,
            fileSize: 1024,
            mode: .anyone
        )

        #expect(result.signedFileURL == url)
        #expect(result.fileSize == 1024)
        #expect(result.mode == .anyone)
    }

    @Test("SigningResult with peopleWhoKnowMe mode")
    func signingResultPeopleWhoKnowMe() {
        let url = URL(filePath: "/path/to/signed.shortcut")
        let result = ShortcutSigner.SigningResult(
            signedFileURL: url,
            fileSize: 2048,
            mode: .peopleWhoKnowMe
        )

        #expect(result.mode == .peopleWhoKnowMe)
    }

    // MARK: - ShortcutSigner Tests

    @Test("ShortcutSigner.shared returns instance")
    func sharedInstanceExists() async {
        let signer = ShortcutSigner.shared
        // Verify the instance can be accessed (actors are always non-nil)
        // Just verify we can call a method on it
        #expect(type(of: signer) == ShortcutSigner.self)
    }

    @Test("sign throws inputFileNotFound for non-existent file")
    func signNonExistentFile() async throws {
        let signer = ShortcutSigner.shared
        let inputURL = URL(filePath: "/non/existent/path/file.shortcut")
        let outputURL = URL(filePath: "/tmp/signed.shortcut")

        do {
            _ = try await signer.sign(input: inputURL, output: outputURL, mode: .anyone)
            #expect(Bool(false), "Expected inputFileNotFound error")
        } catch let error as ShortcutSigner.SigningError {
            switch error {
            case .inputFileNotFound(let path):
                #expect(path.contains("non/existent"))
            default:
                #expect(Bool(false), "Expected inputFileNotFound error, got \(error)")
            }
        }
    }

    @Test("sign with auto-generated output path convenience method")
    func signWithAutoGeneratedOutput() async throws {
        let signer = ShortcutSigner.shared
        let inputURL = URL(filePath: "/non/existent/path/my-shortcut.shortcut")

        do {
            _ = try await signer.sign(input: inputURL, mode: .anyone)
            #expect(Bool(false), "Expected inputFileNotFound error")
        } catch let error as ShortcutSigner.SigningError {
            switch error {
            case .inputFileNotFound:
                // Expected - the convenience method should still check for file existence
                #expect(Bool(true))
            default:
                #expect(Bool(false), "Expected inputFileNotFound error, got \(error)")
            }
        }
    }
}

// MARK: - Integration Tests with Temp Files

@Suite("ShortcutSigner Integration Tests")
struct ShortcutSignerIntegrationTests {

    @Test("Sign a generated shortcut file")
    func signGeneratedShortcut() async throws {
        // Create a minimal shortcut using ShortcutGenerator
        let tempDir = FileManager.default.temporaryDirectory.appending(path: "ShortcutSignerTest-\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create a simple Hello World shortcut
        let config = ShortcutGenerator.Configuration(name: "Test Shortcut")
        let generator = ShortcutGenerator(configuration: config, outputDirectory: tempDir)

        let textAction = TextAction("Hello, World!")
        let showAction = ShowResultAction("Hello, World!")

        let result = try await generator.generate(actions: [textAction, showAction])

        // Now try to sign it
        let signer = ShortcutSigner.shared
        let signedOutputURL = tempDir.appending(path: "test-shortcut-signed.shortcut")

        do {
            let signResult = try await signer.sign(
                input: result.filePath,
                output: signedOutputURL,
                mode: .anyone
            )

            // Verify the signed file was created
            #expect(FileManager.default.fileExists(atPath: signResult.signedFileURL.path))
            #expect(signResult.fileSize > 0)
            #expect(signResult.mode == ShortcutSigner.SigningMode.anyone)

        } catch let error as ShortcutSigner.SigningError {
            // The shortcuts CLI may not be available in all test environments
            // So we accept both success and specific known failures
            switch error {
            case .signingFailed(let message):
                // CLI tool errors are acceptable in test environments
                #expect(
                    message.contains("shortcuts") ||
                    message.contains("not found") ||
                    message.contains("signing") ||
                    message.contains("error"),
                    "Unexpected signing failure: \(message)"
                )
            case .processError(let message):
                #expect(Bool(true), "Process error is acceptable in test environments: \(message)")
            default:
                throw error
            }
        }
    }

    @Test("Sign with peopleWhoKnowMe mode")
    func signWithPeopleWhoKnowMeMode() async throws {
        let tempDir = FileManager.default.temporaryDirectory.appending(path: "ShortcutSignerTest-\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create a simple shortcut
        let config = ShortcutGenerator.Configuration(name: "Private Shortcut")
        let generator = ShortcutGenerator(configuration: config, outputDirectory: tempDir)

        let textAction = TextAction("Private content")
        let result = try await generator.generate(actions: [textAction])

        // Sign with peopleWhoKnowMe mode
        let signer = ShortcutSigner.shared
        let signedOutputURL = tempDir.appending(path: "private-signed.shortcut")

        do {
            let signResult = try await signer.sign(
                input: result.filePath,
                output: signedOutputURL,
                mode: .peopleWhoKnowMe
            )

            #expect(signResult.mode == ShortcutSigner.SigningMode.peopleWhoKnowMe)
            #expect(FileManager.default.fileExists(atPath: signResult.signedFileURL.path))

        } catch let error as ShortcutSigner.SigningError {
            // Accept CLI unavailability in test environments
            switch error {
            case .signingFailed, .processError:
                #expect(Bool(true), "CLI-based signing may not be available in all environments")
            default:
                throw error
            }
        }
    }

    @Test("Sign with auto-generated output path")
    func signAutoGeneratedPath() async throws {
        let tempDir = FileManager.default.temporaryDirectory.appending(path: "ShortcutSignerTest-\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)

        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }

        // Create a shortcut with a specific name
        let config = ShortcutGenerator.Configuration(name: "auto-sign-test")
        let generator = ShortcutGenerator(configuration: config, outputDirectory: tempDir)

        let textAction = TextAction("Test")
        let result = try await generator.generate(actions: [textAction])

        // Sign using the convenience method (auto-generates output path)
        let signer = ShortcutSigner.shared

        do {
            let signedURL = try await signer.sign(input: result.filePath, mode: .anyone)

            // Verify the signed filename has "-signed" appended
            #expect(signedURL.lastPathComponent.contains("-signed"))
            #expect(FileManager.default.fileExists(atPath: signedURL.path))

        } catch let error as ShortcutSigner.SigningError {
            switch error {
            case .signingFailed, .processError:
                #expect(Bool(true), "CLI-based signing may not be available in all environments")
            default:
                throw error
            }
        }
    }
}
